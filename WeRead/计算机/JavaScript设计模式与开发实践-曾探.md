---
doc_type: weread-highlights-reviews
bookId: "27337473"
reviewCount: 0
noteCount: 25
author: 曾探
cover: https://cdn.weread.qq.com/weread/cover/90/YueWen_27337473/t7_YueWen_27337473.jpg
readingStatus: 读完
progress: 100%
totalReadDay: 50
readingTime: 8小时50分钟
readingDate: 2020-10-09
finishedDate: 2022-03-04
isbn: 9787115388889
lastReadDate: 2025-01-16

---
# 元数据
> [!abstract] JavaScript设计模式与开发实践
> - ![ JavaScript设计模式与开发实践|200](https://cdn.weread.qq.com/weread/cover/90/YueWen_27337473/t7_YueWen_27337473.jpg)
> - 书名： JavaScript设计模式与开发实践
> - 作者： 曾探
> - 简介： 本书是根据JavaScript语言的特性专门针对JavaScript语言全面总结的设计模式。全书共分为三个部分，第一部分讲解了JavaScript语言面向对象和函数式编程的知识及其在设计模式方面的作用；第二部分通过一步步完善的代码示例，由浅入深地讲解了16个设计模式；第三部分讲述了面向对象的设计原则及其在设计模式中的体现，以及一些常见的面向对象编程技巧和日常开发中的代码重构。    书中所有示例均来自作者长期的开发实践，与实际开发密切相关，适合Web前端开发人员阅读。
> - 出版时间： 2015-05-12 00:00:00
> - ISBN： 9787115388889
> - 分类： 计算机-编程设计
> - 出版社： 人民邮电出版社
> - PC地址：https://weread.qq.com/web/reader/6bf3215071a123016bf0b74

# 高亮划线

## 前言

> 📌 分辨模式的关键是意图而不是结构 
> ⏱ 2021-07-13 13:49:49 ^27337473-6-5183-5198

### 第1章 面向对象的JavaScript

> 📌 JavaScript没有提供传统面向对象语言中的类式继承，而是通过原型委托的方式来实现对象与对象之间的继承。 
> ⏱ 2025-01-09 22:30:24 ^27337473-8-433-487

#### 1.1 动态类型语言和鸭子类型

> 📌 编程语言按照数据类型大体可以分为两类，一类是静态类型语言，另一类是动态类型语言 
> ⏱ 2025-01-09 22:31:54 ^27337473-9-428-526

> 📌 鸭子类型的通俗说法是：“如果它走起路来像鸭子，叫起来也是鸭子，那么它就是鸭子。” 
> ⏱ 2021-07-15 08:34:00 ^27337473-9-1481-1620

> 📌 鸭子类型指导我们只关注对象的行为，而不关注对象本身 
> ⏱ 2025-01-09 22:36:35 ^27337473-9-2104-2129

> 📌 利用鸭子类型的思想，我们不必借助超类型的帮助，就能轻松地在动态类型语言中实现一个原则：“面向接口编程，而不是面向实现编程” 
> ⏱ 2021-07-15 08:37:53 ^27337473-9-3301-3362

> 📌 只有当对象能够被互相替换使用，才能体现出对象多态性的价值。 
> ⏱ 2025-01-09 22:43:53 ^27337473-9-3609-3638

#### 1.2 多态

> 📌 多态的实际含义是：同一操作作用于不同的对象上面，可以产生不同的解释和不同的执行结果。 
> ⏱ 2025-01-10 07:13:35 ^27337473-10-518-560

> 📌 给不同的对象发送同一个消息的时候，这些对象会根据这个消息分别给出不同的反馈。 
> ⏱ 2025-01-10 07:14:04 ^27337473-10-565-603

> 📌 多态背后的思想是将“做什么”和“谁去做以及怎样去做”分离开来，也就是将“不变的事物”与“可能改变的事物”分离开来。 
> ⏱ 2025-01-10 07:57:49 ^27337473-10-1761-1818

> 📌 静态类型语言在编译时会进行类型匹配检查 
> ⏱ 2022-02-01 06:40:09 ^27337473-10-3376-3395

> 📌 静态类型的面向对象语言通常被设计为可以向上转型：当给一个类变量赋值时，这个变量的类型既可以使用这个类本身，也可以使用这个类的超类。 
> ⏱ 2025-01-10 08:03:17 ^27337473-10-5070-5168

> 📌 让对象表现出多态性的必经之路，而多态性的表现正是实现众多设计模式的目标。 
> ⏱ 2025-01-10 08:04:43 ^27337473-10-5336-5372

> 📌 多态的思想实际上是把“做什么”和“谁去做”分离开来，要实现这一点，归根结底先要消除类型之间的耦合关系。 
> ⏱ 2025-01-10 08:07:45 ^27337473-10-7207-7258

> 📌 多态最根本的作用就是通过把过程化的条件分支语句转化为对象的多态性，从而消除这些条件分支语句。 
> ⏱ 2025-01-12 00:01:49 ^27337473-10-8223-8269

#### 1.3 封装

> 📌 迭代器的作用是在不暴露一个聚合对象的内部表示的前提下，提供一种方式来顺序访问这个聚合对象。 
> ⏱ 2025-01-12 23:01:51 ^27337473-11-2278-2323

> 📌 封装类型是通过抽象类和接口来进行的[插图]。 
> ⏱ 2025-01-12 23:02:51 ^27337473-11-2574-2677

> 📌 《设计模式》一书中共归纳总结了23种设计模式。从意图上区分，这23种设计模式分别被划分为创建型模式、结构型模式和行为型模式。 
> ⏱ 2025-01-12 23:06:14 ^27337473-11-3362-3424

> 📌 创建型模式的目的就是封装创建对象的变化。而结构型模式封装的是对象之间的组合关系。行为型模式封装的是对象的行为变化。 
> ⏱ 2025-01-12 23:07:42 ^27337473-11-3495-3552

> 📌 通过封装变化的方式，把系统中稳定不变的部分和容易变化的部分隔离开来 
> ⏱ 2025-01-12 23:08:12 ^27337473-11-3581-3614

#### 1.4 原型模式和基于原型继承的JavaScript对象系统

> 📌 原型模式不单是一种设计模式，也被称为一种编程泛型。 
> ⏱ 2025-01-15 22:06:27 ^27337473-12-794-819

> 📌 原型模式的真正目的并非在于需要得到一个一模一样的对象，而是提供了一种便捷的方式去创建某个类型的对象，克隆只是创建这个对象的过程和手段。 
> ⏱ 2025-01-13 23:05:29 ^27337473-12-2634-2701

> 📌 JavaScript本身是一门基于原型的面向对象语言，它的对象系统就是使用原型模式来搭建的，在这里称之为原型编程范型也许更合适。 
> ⏱ 2025-01-16 21:18:47 ^27337473-12-3109-3173

#### 2.1 this

> 📌 ❏ 作为对象的方法调用。
   ❏ 作为普通函数调用。
   ❏ 构造器调用。
   ❏ Function.prototype.call或Function.prototype.apply调用。 
> ⏱ 2024-05-27 19:07:59 ^27337473-14-680-854

#### 3.2 高阶函数

> 📌 我们还可以一次性地把Array.prototype上的方法“复制”到array对象上，同样这些方法可操作的对象也不仅仅只是array对象：
   for ( var i = 0, fn, ary = [ 'push', 'shift', 'forEach' ]; fn = ary[ i++ ]; ){
   Array[ fn ] = Array.prototype[ fn ].uncurrying();
   };
   var obj = {
   "length": 3,
   "0": 1,
   "1": 2,
   "2": 3
   };
   Array.push( obj, 4 );     // 向对象中添加一个元素
   console.log( obj.length );    // 输出：4
   var first = Array.shift( obj );    // 截取第一个元素 
> ⏱ 2022-02-26 13:55:48 ^27337473-18-12955

#### 16.1 初识状态模式

> 📌 它可以使每一种状态和它对应的行为之间的关系局部化，这些行为被分散和封装在各自对应的状态类之中，便于阅读和管理代码。 
> ⏱ 2022-05-19 08:39:33 ^27337473-139-7262-7319

#### 22.11 用return退出多重循环

> 📌 for ( var i = 0; i < 10; i++ ){
   for ( var j = 0; j < 10; j++ ){
   if ( i * j >30 ){
   return;
   }
   }
   }
   console.log( i );    // 这句代码没有机会被执行
   };
   为了解决这个问题，我们可以把循环后面的代码放到return后面，如果代码比较多，就应该把它们提炼成一个单独的函数：
   var print = function( i ){
   console.log( i );
   };
   var func = function(){
   for ( var i = 0; i < 10; i++ ){
   for ( var j = 0; j < 10; j++ ){
   if ( i * j >30 ){
   return print( i );
   }
   }
   }
   };
   func(); 
> ⏱ 2020-10-09 12:03:55 ^27337473-190-1818

# 读书笔记
