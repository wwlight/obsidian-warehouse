/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => HKCodeBlockPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// src/settings.ts
var DEFAULT_SETTINGS = {
  useTitleGlobal: "default off, but on when specified",
  useCollapsibleGlobal: "default on, but off when specified",
  defaultCollapse: "expand",
  showCollapseBtn: true,
  useLinenosGlobal: "default off, but on when specified",
  defaultLinenosStart: 1,
  showLinenosSplitter: true,
  useHighlightGlobal: "default off, but on when specified",
  highlightColor: "#ff0000",
  useLanguageGlobal: "default on, but off when specified",
  defaultLanguage: "plain text",
  useCopyBtnGlobal: "default on, but off when specified",
  usePromptGlobal: "default on, but off when specified",
  promptingLanguages: ["bash"],
  defaultPrompt: "$",
  useResultGlobal: true,
  defaultResultPrompt: "Result",
  debugMode: false
};

// src/settingTab.ts
var import_obsidian = require("obsidian");
var fragWithHTML = (text) => {
  return createFragment((frag) => {
    frag.createDiv().innerHTML = text.split("\n").map((line) => line.trim()).join("<br>");
  });
};
var HKCodeBlockSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app2, plugin) {
    super(app2, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Title" });
    new import_obsidian.Setting(containerEl).setName("Use Title").setDesc(fragWithHTML(`- <b>default off, but on when specified</b> : the title will only be shown if the title statement is specified
				- <b>always off</b> : the title will never be shown`)).addDropdown(
      (tc) => tc.addOptions({
        "default off, but on when specified": "default off, but on when specified",
        "always off": "always off"
      }).setValue(this.plugin.settings.useTitleGlobal).onChange(async (value) => {
        this.plugin.settings.useTitleGlobal = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h2", { text: "Collapse" });
    new import_obsidian.Setting(containerEl).setName("Use Collapse").setDesc(fragWithHTML(`- <b>always on</b> : the code block will always be collapsible
				- <b>default on, but off when specified</b> : the code block will always be collapsible, but will not be collapsed if collapse statement is specified as false
				- <b>default off, but on when specified</b> : the code block will only be collapsible if the collapse statement is specified as true
				- <b>always off</b> : the code block will never be collapsible`)).addDropdown(
      (tc) => tc.addOptions({
        "always on": "always on",
        "default on, but off when specified": "default on, but off when specified",
        "default off, but on when specified": "default off, but on when specified",
        "always off": "always off"
      }).setValue(this.plugin.settings.useCollapsibleGlobal).onChange(async (value) => {
        this.plugin.settings.useCollapsibleGlobal = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Default Collapse State").setDesc("The default collapse state of the code block.").addDropdown(
      (tc) => tc.addOptions({
        "collapse": "collapse",
        "expand": "expand"
      }).setValue(this.plugin.settings.defaultCollapse).onChange(async (value) => {
        this.plugin.settings.defaultCollapse = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h2", { text: "Line Numbers" });
    new import_obsidian.Setting(containerEl).setName("Use Line Numbers").setDesc(fragWithHTML(`- <b>always on</b> : line numbers will always be shown
				- <b>default on, but off when specified</b> : line numbers will always be shown, but will not be shown if linenos statement is specified as false
				- <b>default off, but on when specified</b> : line numbers will only be shown if the linenos statement is specified as true
				- <b>always off</b> : line numbers will never be shown`)).addDropdown(
      (tc) => tc.addOptions({
        "always on": "always on",
        "default on, but off when specified": "default on, but off when specified",
        "default off, but on when specified": "default off, but on when specified",
        "always off": "always off"
      }).setValue(this.plugin.settings.useLinenosGlobal).onChange(async (value) => {
        this.plugin.settings.useLinenosGlobal = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Default Line Number Start").setDesc("The default line number start of the code block.").addText(
      (tc) => tc.setValue(this.plugin.settings.defaultLinenosStart.toString()).onChange(async (value) => {
        const num = parseInt(value);
        if (isNaN(num))
          return;
        this.plugin.settings.defaultLinenosStart = num;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Show Line Number Splitter").addToggle(
      (tc) => tc.setValue(this.plugin.settings.showLinenosSplitter).onChange(async (value) => {
        this.plugin.settings.showLinenosSplitter = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h2", { text: "Line Highlight" });
    new import_obsidian.Setting(containerEl).setName("Use Line Highlight").setDesc(fragWithHTML(`- <b>default off, but on when specified</b> : line highlight will only be shown if the line highlight statement is specified
				- <b>always off</b> : line highlight will never be shown`)).addDropdown(
      (tc) => tc.addOptions({
        "default off, but on when specified": "default off, but on when specified",
        "always off": "always off"
      }).setValue(this.plugin.settings.useHighlightGlobal).onChange(async (value) => {
        this.plugin.settings.useHighlightGlobal = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Line Highlight Color").setDesc("The background color of the highlighted line. Note that the given color will be applied with 0.2 opacity.").addText(
      (tc) => tc.setValue(this.plugin.settings.highlightColor).onChange(async (value) => {
        this.plugin.settings.highlightColor = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h2", { text: "Language Indicator" });
    new import_obsidian.Setting(containerEl).setName("Use Language Indicator").setDesc(fragWithHTML(`- <b>always on</b> : language indicator will always be shown
				- <b>default on, but off when specified</b> : language indicator will always be shown, but will not be shown if the language indicator statement is specified as false
				- <b>default off, but on when specified</b> : language indicator will only be shown if the language indicator statement is specified as true
				- <b>always off</b> : language indicator will never be shown`)).addDropdown(
      (tc) => tc.addOptions({
        "always on": "always on",
        "default on, but off when specified": "default on, but off when specified",
        "default off, but on when specified": "default off, but on when specified",
        "always off": "always off"
      }).setValue(this.plugin.settings.useLanguageGlobal).onChange(async (value) => {
        this.plugin.settings.useLanguageGlobal = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Default Language").setDesc("The default language name of the code block if the language is not specified.").addText(
      (tc) => tc.setValue(this.plugin.settings.defaultLanguage).onChange(async (value) => {
        this.plugin.settings.defaultLanguage = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h2", { text: "Copy Button" });
    new import_obsidian.Setting(containerEl).setName("Use Copy Button").setDesc(fragWithHTML(`- <b>always on</b> : copy button will always be shown
				- <b>default on, but off when specified</b> : copy button will always be shown, but will not be shown if the copy button statement is specified as false
				- <b>default off, but on when specified</b> : copy button will only be shown if the copy button statement is specified as true
				- <b>always off</b> : copy button will never be shown`)).addDropdown(
      (tc) => tc.addOptions({
        "always on": "always on",
        "default on, but off when specified": "default on, but off when specified",
        "default off, but on when specified": "default off, but on when specified",
        "always off": "always off"
      }).setValue(this.plugin.settings.useCopyBtnGlobal).onChange(async (value) => {
        this.plugin.settings.useCopyBtnGlobal = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h2", { text: "Prompt" });
    new import_obsidian.Setting(containerEl).setName("Use Prompt").setDesc(fragWithHTML(`- <b>always on</b> : prompt will always be shown
				- <b>default on, but off when specified</b> : prompt will always be shown, but will not be shown if the prompt statement is specified as false
				- <b>default off, but on when specified</b> : prompt will only be shown if the prompt statement is specified as true
				- <b>always off</b> : prompt will never be shown`)).addDropdown(
      (tc) => tc.addOptions({
        "always on": "always on",
        "default on, but off when specified": "default on, but off when specified",
        "default off, but on when specified": "default off, but on when specified",
        "always off": "always off"
      }).setValue(this.plugin.settings.usePromptGlobal).onChange(async (value) => {
        this.plugin.settings.usePromptGlobal = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Prompting Languages").setDesc("The languages that will be prompted by default. You can specify multiple languages by separating them with enters.").addTextArea(
      (tc) => tc.setValue(this.plugin.settings.promptingLanguages.join("\n")).onChange(async (value) => {
        const lines = value.split("\n").filter((line) => line.trim() !== "");
        this.plugin.settings.promptingLanguages = lines;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Default Prompt").setDesc("The default prompt of the bash code block.").addText(
      (tc) => tc.setValue(this.plugin.settings.defaultPrompt).onChange(async (value) => {
        this.plugin.settings.defaultPrompt = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h2", { text: "Result" });
    new import_obsidian.Setting(containerEl).setName("Use Result").setDesc(fragWithHTML(`- <b>enable</b> : treat the code block starts like \`\`\`\`result\` as the result of the adjacent previous code block
				- <b>disable</b> : treat the code block with \`result\` as its language name as a normal code block`)).addToggle(
      (tc) => tc.setValue(this.plugin.settings.useResultGlobal).onChange(async (value) => {
        this.plugin.settings.useResultGlobal = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Default Result Prompt").setDesc("The default prompt of the result code block.").addText(
      (tc) => tc.setValue(this.plugin.settings.defaultResultPrompt).onChange(async (value) => {
        this.plugin.settings.defaultResultPrompt = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h2", { text: "Developers" });
    new import_obsidian.Setting(containerEl).setName("Debug Mode").setDesc("Show logs in the console.").addToggle(
      (tc) => tc.setValue(this.plugin.settings.debugMode).onChange(async (value) => {
        this.plugin.settings.debugMode = value;
        await this.plugin.saveSettings();
      })
    );
  }
};

// src/processor.ts
var import_obsidian2 = require("obsidian");
var REGEX = {
  TITLE: /\stitle:(?:'(.*?)'|"(.*?)")\s/,
  COLLAPSIBLE_SIMPLE: /\scollapsible\s/,
  COLLAPSIBLE_COMPLICATE: /\scollapsible:(true|false)\s/,
  LINENOS_SIMPLE: /\slinenos\s/,
  LINENOS_COMPLICATE: /\slinenos:(true|false|(-{0,1}\d+))\s/,
  HIGHLIGHT: /\shighlight:(?:'(.*?)'|"(.*?)")\s/,
  LANGUAGE_FROM_CLASS: /^language-(\w+)$/,
  LANGUAGE_SIMPLE: /\slanguage\s/,
  LANGUAGE_COMPLICATE: /\slanguage:(true|false|'(.*?)'|"(.*?)")\s/,
  COPYBTN_SIMPLE: /\scopybtn\s/,
  COPYBTN_COMPLICATE: /\scopybtn:(true|false)\s/,
  RESULT: /^```result\s/,
  PROMPT_SIMPLE: /\sprompt\s/,
  PROMPT_COMPLICATE: /\sprompt:(true|false|'(.*?)'|"(.*?)")\s/,
  NUMBER: /^-{0,1}\d+$/
};
function getMeta(view, elem_code, elem_code_idx, section_code, settings) {
  const return_value = {
    isError: false,
    lineStartInSection: -1,
    lineEndInSection: -1,
    showTitle: void 0,
    title: "",
    isCollapsible: void 0,
    showLinenos: void 0,
    linenosStart: settings.defaultLinenosStart,
    linenosNum: 0,
    showHighlight: void 0,
    highlightLines: [],
    showLanguage: void 0,
    language: settings.defaultLanguage,
    showCopyBtn: void 0,
    isResult: false,
    resultPrompt: settings.defaultResultPrompt,
    showPrompt: void 0,
    prompt: settings.defaultPrompt
  };
  let marker_count = 0;
  for (let i = section_code.lineStart; i <= section_code.lineEnd; i++) {
    const line = view.editor.getLine(i);
    if (line.trim().startsWith("```"))
      marker_count++;
    if (return_value.lineStartInSection === -1 && marker_count === elem_code_idx * 2 + 1) {
      return_value.lineStartInSection = i;
    }
    if (return_value.lineEndInSection === -1 && marker_count === elem_code_idx * 2 + 2) {
      return_value.lineEndInSection = i;
      break;
    }
  }
  if (return_value.lineStartInSection < 0 || return_value.lineEndInSection < 0 || return_value.lineStartInSection >= return_value.lineEndInSection) {
    return_value.isError = true;
    return return_value;
  }
  const firstline = view.editor.getLine(return_value.lineStartInSection).trim() + " ";
  const regexResult_title = REGEX.TITLE.exec(firstline);
  if (regexResult_title) {
    return_value.showTitle = true;
    return_value.title = regexResult_title[1] || regexResult_title[2];
  }
  const regexResult_collapsibleSimple = REGEX.COLLAPSIBLE_SIMPLE.exec(firstline);
  const regexResult_collapsibleComplicate = REGEX.COLLAPSIBLE_COMPLICATE.exec(firstline);
  if (regexResult_collapsibleSimple) {
    return_value.isCollapsible = true;
  } else if (regexResult_collapsibleComplicate) {
    if (regexResult_collapsibleComplicate[1] === "true") {
      return_value.isCollapsible = true;
    } else if (regexResult_collapsibleComplicate[1] === "false") {
      return_value.isCollapsible = false;
    }
  }
  return_value.linenosNum = return_value.lineEndInSection - return_value.lineStartInSection - 1;
  const regexResult_linenosSimple = REGEX.LINENOS_SIMPLE.exec(firstline);
  const regexResult_linenosComplicate = REGEX.LINENOS_COMPLICATE.exec(firstline);
  if (regexResult_linenosSimple) {
    return_value.showLinenos = true;
  } else if (regexResult_linenosComplicate) {
    if (regexResult_linenosComplicate[1] === "true") {
      return_value.showLinenos = true;
    } else if (regexResult_linenosComplicate[1] === "false") {
      return_value.showLinenos = false;
    } else {
      return_value.showLinenos = true;
      return_value.linenosStart = parseInt(regexResult_linenosComplicate[2]) || 1;
    }
  }
  const regexResult_highlight = REGEX.HIGHLIGHT.exec(firstline);
  if (regexResult_highlight) {
    return_value.showHighlight = true;
    const highlightLines_str = regexResult_highlight[1] || regexResult_highlight[2];
    let highlightLines = highlightLines_str.split(",").map((item) => {
      item = item.trim();
      if (REGEX.NUMBER.test(item))
        return parseInt(item);
      const multiple_lines = item.split("-");
      if (multiple_lines.length === 2) {
        const start = parseInt(multiple_lines[0].trim());
        const end = parseInt(multiple_lines[1].trim());
        if (!isNaN(start) && !isNaN(end)) {
          return Array.from({ length: end - start + 1 }, (_, i) => i + start);
        }
      }
      return NaN;
    }).flat().filter((item) => !isNaN(item));
    if (highlightLines.some((line) => isNaN(line))) {
      return_value.showHighlight = void 0;
      return_value.highlightLines = [];
    } else {
      return_value.highlightLines = highlightLines.filter(
        (line) => line >= return_value.linenosStart && line < return_value.linenosStart + return_value.linenosNum
      );
    }
  }
  elem_code.classList.forEach((className) => {
    const regexResult_languageFromClass = REGEX.LANGUAGE_FROM_CLASS.exec(className.trim());
    if (regexResult_languageFromClass) {
      return_value.language = regexResult_languageFromClass[1];
    }
  });
  const regexResult_languageSimple = REGEX.LANGUAGE_SIMPLE.exec(firstline);
  const regexResult_languageComplicate = REGEX.LANGUAGE_COMPLICATE.exec(firstline);
  if (regexResult_languageSimple) {
    return_value.showLanguage = true;
  } else if (regexResult_languageComplicate) {
    if (regexResult_languageComplicate[1] === "true") {
      return_value.showLanguage = true;
    } else if (regexResult_languageComplicate[1] === "false") {
      return_value.showLanguage = false;
    } else {
      return_value.showLanguage = true;
      return_value.language = regexResult_languageComplicate[2] || regexResult_languageComplicate[3];
    }
  }
  const regexResult_copyBtnSimple = REGEX.COPYBTN_SIMPLE.exec(firstline);
  const regexResult_copyBtnComplicate = REGEX.COPYBTN_COMPLICATE.exec(firstline);
  if (regexResult_copyBtnSimple) {
    return_value.showCopyBtn = true;
  } else if (regexResult_copyBtnComplicate) {
    if (regexResult_copyBtnComplicate[1] === "true") {
      return_value.showCopyBtn = true;
    } else if (regexResult_copyBtnComplicate[1] === "false") {
      return_value.showCopyBtn = false;
    }
  }
  const regexResult_promptSimple = REGEX.PROMPT_SIMPLE.exec(firstline);
  const regexResult_promptComplicate = REGEX.PROMPT_COMPLICATE.exec(firstline);
  if (regexResult_promptSimple) {
    return_value.showPrompt = true;
  } else if (regexResult_promptComplicate) {
    if (regexResult_promptComplicate[1] === "true") {
      return_value.showPrompt = true;
    } else if (regexResult_promptComplicate[1] === "false") {
      return_value.showPrompt = false;
    } else {
      return_value.showPrompt = true;
      return_value.prompt = regexResult_promptComplicate[2] || regexResult_promptComplicate[3];
    }
  }
  const regexResult_result = REGEX.RESULT.exec(firstline);
  const regexResultPrompt_result = REGEX.PROMPT_COMPLICATE.exec(firstline);
  if (regexResult_result) {
    return_value.isResult = true;
    return_value.showTitle = false;
    return_value.showLanguage = false;
    return_value.showCopyBtn = false;
    return_value.showPrompt = false;
    if (regexResultPrompt_result) {
      return_value.resultPrompt = regexResultPrompt_result[2] || regexResultPrompt_result[3];
    }
  }
  return return_value;
}
function HKCodeBlockProcessor(el, context, plugin) {
  const settings = plugin.settings;
  const view = app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView);
  if (!view)
    return;
  const elem_codes = el.querySelectorAll("pre:not(.frontmatter) > code");
  if (elem_codes.length === 0)
    return;
  elem_codes.forEach((elem_code, elem_code_idx) => {
    const elem_pre = elem_code.parentElement;
    if (!elem_pre)
      return;
    const elem_pre_parent = elem_pre.parentElement;
    if (!elem_pre_parent)
      return;
    const elem_copyBtn = elem_pre.querySelector(".copy-code-button");
    if (!elem_copyBtn)
      return;
    const section_code = context.getSectionInfo(elem_code);
    if (!section_code)
      return;
    const {
      isError,
      lineStartInSection,
      lineEndInSection,
      showTitle,
      title,
      isCollapsible,
      showLinenos,
      linenosStart,
      linenosNum,
      showHighlight,
      highlightLines,
      showLanguage,
      language,
      showCopyBtn,
      isResult,
      resultPrompt,
      showPrompt,
      prompt
    } = getMeta(view, elem_code, elem_code_idx, section_code, settings);
    if (isError)
      return;
    if (settings.debugMode) {
      console.log({
        isError,
        lineStartInSection,
        lineEndInSection,
        showTitle,
        title,
        isCollapsible,
        showLinenos,
        linenosStart,
        linenosNum,
        showHighlight,
        highlightLines,
        showLanguage,
        language,
        showCopyBtn,
        isResult,
        resultPrompt,
        showPrompt,
        prompt
      });
    }
    const elem_div = document.createElement("div");
    elem_pre_parent.replaceChild(elem_div, elem_pre);
    elem_div.appendChild(elem_pre);
    elem_div.classList.add("hk-codeblock");
    elem_code.classList.add("hk-codeblock-code");
    elem_copyBtn.remove();
    let elem_title = void 0;
    if (settings.useTitleGlobal === "default off, but on when specified" && showTitle === true) {
      elem_div.classList.add("hk-codeblock-show-title");
      elem_title = document.createElement("div");
      elem_title.classList.add("hk-codeblock-title");
      elem_title.innerHTML = title;
      elem_div.insertBefore(elem_title, elem_pre);
    }
    if (settings.useCollapsibleGlobal === "always on" || settings.useCollapsibleGlobal === "default on, but off when specified" && (isCollapsible === void 0 || isCollapsible === true) || settings.useCollapsibleGlobal === "default off, but on when specified" && isCollapsible === true) {
      if (elem_title) {
        elem_div.classList.add("hk-codeblock-collapsible");
        if (settings.defaultCollapse === "collapse") {
          elem_div.classList.add("hk-codeblock-collapsed");
        }
        elem_title.addEventListener("click", (ev) => {
          ev.stopPropagation();
          ev.preventDefault();
          elem_div.classList.toggle("hk-codeblock-collapsed");
        });
        const elem_collapseBtns = document.createElement("div");
        elem_collapseBtns.classList.add("hk-codeblock-collapse-btns");
        const elem_collapseBtn = document.createElement("div");
        elem_collapseBtn.classList.add("hk-codeblock-collapse-btn", "hk-codeblock-collapsed-btn");
        elem_collapseBtn.innerHTML = `<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
        <path d="M10 19a1 1 0 0 1-.64-.23 1 1 0 0 1-.13-1.41L13.71 12 9.39 6.63a1 1 0 0 1 .15-1.41 1 1 0 0 1 1.46.15l4.83 6a1 1 0 0 1 0 1.27l-5 6A1 1 0 0 1 10 19z"/>
      </svg>`;
        elem_collapseBtns.appendChild(elem_collapseBtn);
        const elem_expandBtn = document.createElement("div");
        elem_expandBtn.classList.add("hk-codeblock-collapse-btn", "hk-codeblock-expanded-btn");
        elem_expandBtn.innerHTML = `<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
        <path d="M12 16a1 1 0 0 1-.64-.23l-6-5a1 1 0 1 1 1.28-1.54L12 13.71l5.36-4.32a1 1 0 0 1 1.41.15 1 1 0 0 1-.14 1.46l-6 4.83A1 1 0 0 1 12 16z"/>
      </svg>`;
        elem_collapseBtns.appendChild(elem_expandBtn);
        elem_title.prepend(elem_collapseBtns);
      }
    }
    if (settings.useLinenosGlobal === "always on" || settings.useLinenosGlobal === "default on, but off when specified" && (showLinenos === void 0 || showLinenos === true) || settings.useLinenosGlobal === "default off, but on when specified" && showLinenos === true) {
      elem_div.classList.add("hk-codeblock-show-linenos");
      const elem_linenos = document.createElement("div");
      elem_linenos.classList.add("hk-codeblock-linenos");
      elem_linenos.innerText = Array(linenosNum).fill(0).map((_, idx) => idx + linenosStart).join("\n");
      elem_pre.insertBefore(elem_linenos, elem_code);
      if (settings.showLinenosSplitter) {
        elem_linenos.classList.add("show-splitter");
      }
    }
    if (settings.useHighlightGlobal === "default off, but on when specified" && showHighlight === true) {
      elem_div.classList.add("hk-codeblock-show-highlight");
      elem_div.style.setProperty("--hk-codeblock-highlight-background-color", settings.highlightColor);
      const elem_highlight = document.createElement("div");
      elem_highlight.classList.add("hk-codeblock-highlight");
      elem_highlight.innerHTML = Array(linenosNum).fill(0).map((_, idx) => {
        const classNames = [];
        if (highlightLines.includes(idx + linenosStart))
          classNames.push("highlight");
        return `<span class="line line-${idx + linenosStart} ${classNames.join(" ")}"> </span>`;
      }).join("\n");
      elem_pre.insertBefore(elem_highlight, elem_code);
    }
    if (settings.useLanguageGlobal === "always on" || settings.useLanguageGlobal === "default on, but off when specified" && (showLanguage === void 0 || showLanguage === true) || settings.useLanguageGlobal === "default off, but on when specified" && showLanguage === true) {
      elem_div.classList.add("hk-codeblock-show-language");
      const elem_language = document.createElement("div");
      elem_language.classList.add("hk-codeblock-language");
      elem_language.innerText = language;
      elem_pre.prepend(elem_language);
    }
    if (settings.useCopyBtnGlobal === "always on" || settings.useCopyBtnGlobal === "default on, but off when specified" && (showCopyBtn === void 0 || showCopyBtn === true) || settings.useCopyBtnGlobal === "default off, but on when specified" && showCopyBtn === true) {
      elem_div.classList.add("hk-codeblock-show-copybtn");
      elem_pre.appendChild(elem_copyBtn);
    }
    if (settings.usePromptGlobal === "always on" && settings.promptingLanguages.includes(language) || settings.usePromptGlobal === "default on, but off when specified" && settings.promptingLanguages.includes(language) && (showPrompt === void 0 || showPrompt === true) || settings.usePromptGlobal === "default off, but on when specified" && showPrompt === true) {
      elem_div.classList.add("hk-codeblock-show-prompt");
      const elem_prompt = document.createElement("div");
      elem_prompt.classList.add("hk-codeblock-prompt");
      const lines = elem_code.innerText.split("\n");
      elem_prompt.innerText = Array(linenosNum).fill(0).map((_, idx) => {
        if (idx < 0 || idx >= lines.length)
          return null;
        const line = lines[idx].trim();
        const prevLine = idx > 0 ? lines[idx - 1].trim() : "";
        if (line === "" || // check if the line is empty
        line.startsWith("#") || // check if the line is a comment
        prevLine.endsWith("\\")) {
          return " ".repeat(prompt.length);
        }
        return prompt;
      }).filter((line) => line !== null).join("\n");
      elem_pre.insertBefore(elem_prompt, elem_code);
    }
    if (settings.useResultGlobal === true && isResult === true) {
      const isCodeBlockAdjacent = (() => {
        let line_idx = lineStartInSection - 1;
        while (line_idx >= 0) {
          const line = view.editor.getLine(line_idx).trim();
          if (line.length === 0) {
            line_idx--;
            continue;
          } else if (line === "```") {
            return true;
          } else {
            return false;
          }
        }
        return false;
      })();
      if (isCodeBlockAdjacent) {
        elem_div.classList.add("hk-codeblock-result");
        elem_code.classList.add("hk-codeblock-result-code");
        const elem_result_prompt = document.createElement("div");
        elem_result_prompt.classList.add("hk-codeblock-result-prompt");
        elem_result_prompt.innerText = resultPrompt;
        elem_div.insertBefore(elem_result_prompt, elem_pre);
      }
    }
  });
}

// src/main.ts
var HKCodeBlockPlugin = class extends import_obsidian3.Plugin {
  async onload() {
    await this.loadSettings();
    if (this.settings.debugMode) {
      console.log("loading HK Code Block plugin");
    }
    this.addSettingTab(new HKCodeBlockSettingTab(this.app, this));
    const processor = this.registerMarkdownPostProcessor((el, ctx) => {
      HKCodeBlockProcessor(el, ctx, this);
    });
    processor.sortOrder = 100;
  }
  onunload() {
    if (this.settings.debugMode) {
      console.log("unloading HKCodeBlock plugin");
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};


/* nosourcemap */