---
doc_type: weread-highlights-reviews
bookId: "3300028078"
reviewCount: 0
noteCount: 27
author: 霍春阳　著
cover: https://cdn.weread.qq.com/weread/cover/96/cpPlatform_kmqPY1boCDVyMxq2AvPdCY/t7_cpPlatform_kmqPY1boCDVyMxq2AvPdCY.jpg
readingStatus: 在读
progress: 14%
totalReadDay: 11
readingTime: 4小时9分钟
readingDate: 2022-09-10
isbn: 9787115583864
lastReadDate: 2022-09-13

---
# 元数据
> [!abstract] Vue.js设计与实现
> - ![ Vue.js设计与实现|200](https://cdn.weread.qq.com/weread/cover/96/cpPlatform_kmqPY1boCDVyMxq2AvPdCY/t7_cpPlatform_kmqPY1boCDVyMxq2AvPdCY.jpg)
> - 书名： Vue.js设计与实现
> - 作者： 霍春阳　著
> - 简介： 本书基于Vue.js 3，从规范出发，以源码为基础，并结合大量直观的配图，循序渐进地讲解Vue.js中各个功能模块的实现，细致剖析框架设计原理。全书共18章，分为六篇，主要内容包括：框架设计概览、响应系统、渲染器、组件化、编译器和服务端渲染等。通过阅读本书，对Vue.js 2/3具有上手经验的开发人员能够进一步理解Vue.js框架的实现细节，没有Vue.js使用经验但对框架设计感兴趣的前端开发人员，能够快速掌握Vue.js的设计原理。
> - 出版时间： 2022-01-01 00:00:00
> - ISBN： 9787115583864
> - 分类： 计算机-软件学习
> - 出版社： 人民邮电出版社
> - PC地址：https://weread.qq.com/web/reader/c5c32170813ab7177g0181ae

# 高亮划线

### 第1章 权衡的艺术

> 📌 早年间流行的 jQuery 就是典型的命令式框架。命令式框架的一大特点就是关注过程。 
> ⏱ 2022-09-10 09:01:18 ^3300028078-6-1051-1119

> 📌 至于实现该“结果”的过程，则是由 Vue.js 帮我们完成的。换句话说，Vue.js 帮我们封装了过程。因此，我们能够猜到 Vue.js 的内部实现一定是命令式的，而暴露给用户的却更加声明式。 
> ⏱ 2022-09-10 09:09:44 ^3300028078-6-2149-2349

> 📌 为了实现最优的更新性能，它需要找到前后的差异并只更新变化的地方，但是最终完成这次更新的代码仍然是： 
> ⏱ 2022-09-10 09:10:48 ^3300028078-6-3098-3147

> 📌 在采用命令式代码开发的时候，我们需要维护实现目标的整个过程，包括要手动完成 DOM 元素的创建、更新、删除等工作。而声明式代码展示的就是我们要的结果， 
> ⏱ 2022-09-10 09:14:09 ^3300028078-6-3705-3832

> 📌 在保持可维护性的同时让性能损失最小化。 
> ⏱ 2022-09-10 09:15:29 ^3300028078-6-3993-4019

> 📌 声明式代码的更新性能消耗 = 找出差异的性能消耗 + 直接修改的性能消耗 
> ⏱ 2022-09-10 09:16:06 ^3300028078-6-4294-4330

> 📌 命令式更加关注过程，而声明式更加关注结果 
> ⏱ 2022-09-12 11:51:50 ^3300028078-6-13314-13334

> 📌 接着，我们讨论了虚拟 DOM 的性能，并给出了一个公式：声明式的更新性能消耗 = 找出差异的性能消耗 + 直接修改的性能消耗。虚拟 DOM 的意义就在于使找出差异的性能消耗最小化 
> ⏱ 2022-09-12 11:52:14 ^3300028078-6-13445-13560

> 📌 Vue.js 3 是一个编译时 + 运行时的框架，它在保持灵活性的基础上，还能够通过编译手段分析用户提供的内容，从而进一步提升更新性能。 
> ⏱ 2022-09-12 11:54:22 ^3300028078-6-13969-14037

### 第2章 框架设计的核心要素

> 📌 以 Chrome 为例，我们可以打开 DevTools 的设置，然后勾选“Console”→“Enable custom formatters”选项 
> ⏱ 2022-09-12 15:36:39 ^3300028078-7-2850-2924

> 📌 __DEV__ 常量替换为字面量 false，这时我们发现这段分支代码永远都不会执行，因为判断条件始终为假，这段永远不会执行的代码称为 dead code，它不会出现在最终产物中，在构建资源的时候就会被移除，因此在 vue.global.prod.js 中是不会存在这段代码的。 
> ⏱ 2022-09-12 16:27:34 ^3300028078-7-4991-5130

> 📌 希望用户可以直接在 HTML 页面中使用 <script> 标签引入框架并使用 
> ⏱ 2022-09-13 09:40:26 ^3300028078-7-8794-8833

> 📌 IIFE 的全称是 Immediately Invoked Function Expression，即“立即调用的函数表达式” 
> ⏱ 2022-09-13 09:40:40 ^3300028078-7-9094-9157

> 📌 Tree-Shaking 机制，配合构建工具预定义常量的能力，例如预定义 __DEV__ 常量，从而实现仅在开发环境中打印警告信息，而生产环境中则不包含这些用于提升开发体验的代码，从而实现线上代码体积的可控性 
> ⏱ 2022-09-13 09:38:56 ^3300028078-7-19463-19567

### 第3章 Vue.js 3 的设计思路

> 📌 渲染器的作用就是把虚拟 DOM 渲染为真实 DOM 
> ⏱ 2022-09-13 10:23:22 ^3300028078-8-4102-4127

> 📌 渲染器的工作原理其实很简单，归根结底，都是使用一些我们熟悉的 DOM 操作 API 来完成渲染工作 
> ⏱ 2022-09-13 10:29:37 ^3300028078-8-7697-7746

> 📌 组件就是一组 DOM 元素的封装 
> ⏱ 2022-09-13 10:32:19 ^3300028078-8-8165-8181

> 📌 Vue.js 是一个声明式的框架。声明式的好处在于，它直接描述结果，用户不需要关注过程。Vue.js 采用模板的方式来描述 UI，但它同样支持使用虚拟 DOM 来描述 UI。虚拟 DOM 要比模板更加灵活，但模板要比虚拟 DOM 更加直观。 
> ⏱ 2022-09-13 12:45:56 ^3300028078-8-15412-15532

> 📌 渲染器的作用是，把虚拟 DOM 对象渲染为真实 DOM 元素。它的工作原理是，递归地遍历虚拟 DOM 对象，并调用原生 DOM API 来完成真实 DOM 的创建。渲染器的精髓在于后续的更新，它会通过 Diff 算法找出变更点，并且只会更新需要更新的内容。 
> ⏱ 2022-09-13 12:49:00 ^3300028078-8-15579-15707

> 📌 组件其实就是一组虚拟 DOM 元素的封装，它可以是一个返回虚拟 DOM 的函数，也可以是一个对象，但这个对象下必须要有一个函数用来产出组件要渲染的虚拟 DOM。 
> ⏱ 2022-09-13 12:50:09 ^3300028078-8-15768-15848

### 第4章 响应系统的作用与实现

> 📌 当读取操作发生时，将副作用函数收集到“桶”中； 
> ⏱ 2022-09-13 21:29:22 ^3300028078-10-4690-4739

> 📌 当设置操作发生时，从“桶”中取出副作用函数并执行。 
> ⏱ 2022-09-13 21:29:24 ^3300028078-10-4769-4821

> 📌 尝试用代码来实现这个新的“桶”。 
> ⏱ 2022-09-13 21:40:04 ^3300028078-10-8924-8940

> 📌 get/set 拦截器代码 
> ⏱ 2022-09-13 21:39:49 ^3300028078-10-9068-9082

> 📌 key 的依赖集合 
> ⏱ 2022-09-13 21:41:57 ^3300028078-10-10946-10974

> 📌 WeakMap 和 Map 的区别 
> ⏱ 2022-09-13 21:44:19 ^3300028078-10-11054-11071

> 📌 WeakMap 对 key 是弱引用，不影响垃圾回收器的工作。 
> ⏱ 2022-09-13 21:44:30 ^3300028078-10-11767-11798

# 读书笔记

